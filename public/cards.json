[
  {
    "id": 1,
    "title": "Two Sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    "example": "Example: nums = [2,7,11,15], target = 9 -> [0,1]",
    "answer": "Answer for Two Sum",
    "type": "Array",
    "difficulty": "Easy",
    "codeanswer": "def twoSum(nums, target):\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n",
    "answerexplanation": "The function uses a hashmap to store the indices of the elements. For each element, it checks if the complement (target - element) exists in the hashmap. If it does, it returns the indices."
  },
  {
    "id": 2,
    "title": "Best Time to Buy and Sell Stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
    "example": "Example: prices = [7,1,5,3,6,4] -> 5",
    "answer": "Answer for Best Time to Buy and Sell Stock",
    "type": "Array",
    "difficulty": "Easy",
    "codeanswer": "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n    return max_profit\n",
    "answerexplanation": "The function iterates through the list of prices, keeping track of the minimum price seen so far and the maximum profit possible by selling at the current price."
  },
  {
    "id": 3,
    "title": "Contains Duplicate",
    "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
    "example": "Example: nums = [1,2,3,1] -> true",
    "answer": "Answer for Contains Duplicate",
    "type": "Array",
    "difficulty": "Easy",
    "codeanswer": "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n",
    "answerexplanation": "The function uses a set to remove duplicates and then compares the length of the set with the length of the original array. If they are different, it means there were duplicates."
  },
  {
    "id": 4,
    "title": "Product of Array Except Self",
    "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
    "example": "Example: nums = [1,2,3,4] -> [24,12,8,6]",
    "answer": "Answer for Product of Array Except Self",
    "type": "Array",
    "difficulty": "Medium",
    "codeanswer": "def productExceptSelf(nums):\n    length = len(nums)\n    answer = [1] * length\n    left_product = 1\n    for i in range(length):\n        answer[i] = left_product\n        left_product *= nums[i]\n    right_product = 1\n    for i in range(length - 1, -1, -1):\n        answer[i] *= right_product\n        right_product *= nums[i]\n    return answer\n",
    "answerexplanation": "The function calculates the product of all elements to the left of each index and stores it in the answer array. Then, it multiplies the product of all elements to the right of each index with the values in the answer array."
  },
  {
    "id": 5,
    "title": "Maximum Subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
    "example": "Example: nums = [-2,1,-3,4,-1,2,1,-5,4] -> 6",
    "answer": "Answer for Maximum Subarray",
    "type": "Array",
    "difficulty": "Easy",
    "codeanswer": "def maxSubArray(nums):\n    max_sum = nums[0]\n    current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum\n",
    "answerexplanation": "The function uses Kadane's algorithm to find the maximum subarray sum. It keeps track of the maximum sum ending at the current position and updates the global maximum sum if the current sum is higher."
  },
  {
    "id": 6,
    "title": "Maximum Product Subarray",
    "description": "Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.",
    "example": "Example: nums = [2,3,-2,4] -> 6",
    "answer": "Answer for Maximum Product Subarray",
    "type": "Array",
    "difficulty": "Medium",
    "codeanswer": "def maxProduct(nums):\n    if not nums:\n        return 0\n    max_product = min_product = result = nums[0]\n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n        result = max(result, max_product)\n    return result\n",
    "answerexplanation": "The function keeps track of both the maximum and minimum products ending at the current position because a negative number can turn the smallest product into the largest product."
  },
  {
    "id": 7,
    "title": "Find Minimum in Rotated Sorted Array",
    "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Given the sorted rotated array nums of unique elements, return the minimum element of this array.",
    "example": "Example: nums = [3,4,5,1,2] -> 1",
    "answer": "Answer for Find Minimum in Rotated Sorted Array",
    "type": "Array",
    "difficulty": "Medium",
    "codeanswer": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n",
    "answerexplanation": "The function uses binary search to find the minimum element. It compares the middle element with the rightmost element to determine which half of the array contains the minimum element."
  },
  {
    "id": 8,
    "title": "Search in Rotated Sorted Array",
    "description": "There is an integer array nums sorted in ascending order (with distinct values). Given the array nums after the rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
    "example": "Example: nums = [4,5,6,7,0,1,2], target = 0 -> 4",
    "answer": "Answer for Search in Rotated Sorted Array",
    "type": "Array",
    "difficulty": "Medium",
    "codeanswer": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n",
    "answerexplanation": "The function uses binary search to find the target element. It determines which half of the array is sorted and checks if the target is in that half."
  },
  {
    "id": 9,
    "title": "3Sum",
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
    "example": "Example: nums = [-1,0,1,2,-1,-4] -> [[-1,-1,2],[-1,0,1]]",
    "answer": "Answer for 3Sum",
    "type": "Array",
    "difficulty": "Medium",
    "codeanswer": "def threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            s = nums[i] + nums[left] + nums[right]\n            if s < 0:\n                left += 1\n            elif s > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result\n",
    "answerexplanation": "The function sorts the array and then uses a two-pointer approach to find triplets that sum to zero. It skips duplicate elements to avoid duplicate triplets in the result."
  },
  {
    "id": 10,
    "title": "Container With Most Water",
    "description": "Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.",
    "example": "Example: height = [1,8,6,2,5,4,8,3,7] -> 49",
    "answer": "Answer for Container With Most Water",
    "type": "Array",
    "difficulty": "Medium",
    "codeanswer": "def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    while left < right:\n        width = right - left\n        max_area = max(max_area, min(height[left], height[right]) * width)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n",
    "answerexplanation": "The function uses a two-pointer approach to find the maximum area. It starts with the widest container and moves the pointers inward, always moving the pointer pointing to the shorter line."
  },
  {
    "id": 11,
    "title": "Sum of Two Integers",
    "description": "Given two integers a and b, return the sum of the two integers without using the operators + and -.",
    "example": "Example: a = 1, b = 2 -> 3",
    "answer": "Answer for Sum of Two Integers",
    "type": "Binary",
    "difficulty": "Medium",
    "codeanswer": "def getSum(a, b):\n    MAX = 0x7FFFFFFF\n    mask = 0xFFFFFFFF\n    while b != 0:\n        a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n    return a if a <= MAX else ~(a ^ mask)\n",
    "answerexplanation": "The function uses bitwise operations to add the two integers. It uses XOR to add without carrying and AND followed by left shift to calculate the carry. This process is repeated until there is no carry."
  },
  {
    "id": 12,
    "title": "Number of 1 Bits",
    "description": "Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).",
    "example": "Example: n = 00000000000000000000000000001011 -> 3",
    "answer": "Answer for Number of 1 Bits",
    "type": "Binary",
    "difficulty": "Easy",
    "codeanswer": "def hammingWeight(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n",
    "answerexplanation": "The function uses bitwise operations to count the number of '1' bits. It repeatedly clears the least significant '1' bit by using `n & (n - 1)` and increments the count until `n` becomes zero."
  },
  {
    "id": 13,
    "title": "Counting Bits",
    "description": "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.",
    "example": "Example: n = 2 -> [0,1,1]",
    "answer": "Answer for Counting Bits",
    "type": "Binary",
    "difficulty": "Easy",
    "codeanswer": "def countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i >> 1] + (i & 1)\n    return ans\n",
    "answerexplanation": "The function uses dynamic programming to calculate the number of '1' bits for each number from 0 to `n`. It uses the formula `ans[i] = ans[i >> 1] + (i & 1)` to derive the count."
  },
  {
    "id": 14,
    "title": "Missing Number",
    "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    "example": "Example: nums = [3,0,1] -> 2",
    "answer": "Answer for Missing Number",
    "type": "Binary",
    "difficulty": "Easy",
    "codeanswer": "def missingNumber(nums):\n    n = len(nums)\n    return n * (n + 1) // 2 - sum(nums)\n",
    "answerexplanation": "The function calculates the sum of the first `n` natural numbers using the formula `n * (n + 1) // 2` and subtracts the sum of the elements in the array to find the missing number."
  },
  {
    "id": 15,
    "title": "Reverse Bits",
    "description": "Reverse bits of a given 32 bits unsigned integer.",
    "example": "Example: n = 00000010100101000001111010011100 -> 964176192",
    "answer": "Answer for Reverse Bits",
    "type": "Binary",
    "difficulty": "Easy",
    "codeanswer": "def reverseBits(n):\n    result = 0\n    for i in range(32):\n        result = (result << 1) | (n & 1)\n        n >>= 1\n    return result\n",
    "answerexplanation": "The function reverses the bits of the given integer by iterating through each bit, shifting the result to the left, and adding the least significant bit of `n` to the result."
  },
  {
    "id": 16,
    "title": "Climbing Stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "example": "Example: n = 2 -> 2",
    "answer": "Answer for Climbing Stairs",
    "type": "Dynamic Programming",
    "difficulty": "Easy",
    "codeanswer": "def climbStairs(n):\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = 1, 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n",
    "answerexplanation": "The function uses dynamic programming to calculate the number of distinct ways to climb the stairs. It initializes the base cases and then uses the relation `dp[i] = dp[i - 1] + dp[i - 2]` to fill the dp array."
  },
  {
    "id": 17,
    "title": "Coin Change",
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.",
    "example": "Example: coins = [1,2,5], amount = 11 -> 3",
    "answer": "Answer for Coin Change",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for coin in coins:\n        for x in range(coin, amount + 1):\n            dp[x] = min(dp[x], dp[x - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n",
    "answerexplanation": "The function uses dynamic programming to find the minimum number of coins needed. It initializes a dp array with `float('inf')` and sets `dp[0]` to 0. For each coin, it updates the dp array to reflect the minimum number of coins needed to make up each amount."
  },
  {
    "id": 18,
    "title": "Longest Increasing Subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
    "example": "Example: nums = [10,9,2,5,3,7,101,18] -> 4",
    "answer": "Answer for Longest Increasing Subsequence",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def lengthOfLIS(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n",
    "answerexplanation": "The function uses dynamic programming to find the length of the longest increasing subsequence. It initializes a dp array with 1s and updates it by comparing each element with the previous elements to find the longest subsequence ending at each position."
  },
  {
    "id": 19,
    "title": "Longest Common Subsequence",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.",
    "example": "Example: text1 = \"abcde\", text2 = \"ace\" -> 3",
    "answer": "Answer for Longest Common Subsequence",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def longestCommonSubsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n",
    "answerexplanation": "The function uses dynamic programming to find the length of the longest common subsequence. It initializes a 2D dp array with zeros and updates it by comparing characters from the two strings and taking the maximum value from adjacent cells."
  },
  {
    "id": 20,
    "title": "Word Break",
    "description": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.",
    "example": "Example: s = \"leetcode\", wordDict = [\"leet\",\"code\"] -> true",
    "answer": "Answer for Word Break",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def wordBreak(s, wordDict):\n    word_set = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[-1]\n",
    "answerexplanation": "The function uses dynamic programming to determine if the string can be segmented into words from the dictionary. It initializes a dp array with False and sets `dp[0]` to True. It then iterates through the string and checks if any substring is in the word dictionary and can form a valid segmentation."
  },
  {
    "id": 21,
    "title": "Combination Sum",
    "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.",
    "example": "Example: candidates = [2,3,6,7], target = 7 -> [[2,2,3],[7]]",
    "answer": "Answer for Combination Sum",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def combinationSum(candidates, target):\n    result = []\n    def backtrack(start, target, path):\n        if target == 0:\n            result.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > target:\n                break\n            backtrack(i, target - candidates[i], path + [candidates[i]])\n    candidates.sort()\n    backtrack(0, target, [])\n    return result\n",
    "answerexplanation": "The function uses backtracking to find all unique combinations that sum to the target. It recursively subtracts the current candidate from the target and adds it to the path. If the target becomes zero, it adds the path to the result."
  },
  {
    "id": 22,
    "title": "House Robber",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.",
    "example": "Example: nums = [1,2,3,1] -> 4",
    "answer": "Answer for House Robber",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def rob(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    dp = [0] * len(nums)\n    dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n    return dp[-1]\n",
    "answerexplanation": "The function uses dynamic programming to find the maximum amount of money that can be robbed. It initializes a dp array with the maximum values for the first two houses and then iterates through the rest of the houses, updating the dp array with the maximum values."
  },
  {
    "id": 23,
    "title": "House Robber II",
    "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one.",
    "example": "Example: nums = [2,3,2] -> 3",
    "answer": "Answer for House Robber II",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def rob(nums):\n    def rob_linear(nums):\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0] * len(nums)\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n        return dp[-1]\n    return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))\n",
    "answerexplanation": "The function handles the circular arrangement by calling a helper function `rob_linear` twice: once excluding the last house and once excluding the first house. It returns the maximum value obtained from the two calls."
  },
  {
    "id": 24,
    "title": "Decode Ways",
    "description": "A message containing letters from A-Z can be encoded into numbers using the following mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. Given a string s containing only digits, return the number of ways to decode it.",
    "example": "Example: s = \"12\" -> 2",
    "answer": "Answer for Decode Ways",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def numDecodings(s):\n    if not s:\n        return 0\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 0 if s[0] == '0' else 1\n    for i in range(2, n + 1):\n        if s[i - 1] != '0':\n            dp[i] += dp[i - 1]\n        if s[i - 2] == '1' or (s[i - 2] == '2' and s[i - 1] in '0123456'):\n            dp[i] += dp[i - 2]\n    return dp[n]\n",
    "answerexplanation": "The function uses dynamic programming to count the number of ways to decode the string. It initializes a dp array with `dp[0]` set to 1 and `dp[1]` based on the first character. It then iterates through the string, updating the dp array based on the current and previous characters."
  },
  {
    "id": 25,
    "title": "Unique Paths",
    "description": "A robot is located at the top-left corner of a m x n grid. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.",
    "example": "Example: m = 3, n = 7 -> 28",
    "answer": "Answer for Unique Paths",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[-1][-1]\n",
    "answerexplanation": "The function uses dynamic programming to calculate the number of unique paths. It initializes a 2D dp array with 1s and iterates through the grid, updating each cell with the sum of the values from the cell above and the cell to the left."
  },
  {
    "id": 26,
    "title": "Jump Game",
    "description": "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.",
    "example": "Example: nums = [2,3,1,1,4] -> true",
    "answer": "Answer for Jump Game",
    "type": "Dynamic Programming",
    "difficulty": "Medium",
    "codeanswer": "def canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True\n",
    "answerexplanation": "The function iterates through the array, keeping track of the maximum index that can be reached. If the current index is greater than the maximum reach, it returns False. Otherwise, it updates the maximum reach and continues."
  },
  {
    "id": 27,
    "title": "Merge Intervals",
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    "example": "Example: intervals = [[1,3],[2,6],[8,10],[15,18]] -> [[1,6],[8,10],[15,18]]",
    "answer": "Answer for Merge Intervals",
    "type": "Interval",
    "difficulty": "Medium",
    "codeanswer": "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n    for interval in intervals:\n        if not merged or merged[-1][1] < interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n    return merged\n",
    "answerexplanation": "The function sorts the intervals by their start times and then iterates through the sorted intervals. It merges overlapping intervals by updating the end time of the last interval in the merged list."
  },
  {
    "id": 28,
    "title": "Insert Interval",
    "description": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] representing the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.",
    "example": "Example: intervals = [[1,3],[6,9]], newInterval = [2,5] -> [[1,5],[6,9]]",
    "answer": "Answer for Insert Interval",
    "type": "Interval",
    "difficulty": "Medium",
    "codeanswer": "def insert(intervals, newInterval):\n    result = []\n    i = 0\n    while i < len(intervals) and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    while i < len(intervals) and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    while i < len(intervals):\n        result.append(intervals[i])\n        i += 1\n    return result\n",
    "answerexplanation": "The function iterates through the intervals and adds the non-overlapping intervals to the result list. It then merges the overlapping intervals with the new interval and adds the remaining intervals to the result list."
  },
  {
    "id": 29,
    "title": "Non-overlapping Intervals",
    "description": "Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.",
    "example": "Example: intervals = [[1,2],[2,3],[3,4],[1,3]] -> 1",
    "answer": "Answer for Non-overlapping Intervals",
    "type": "Interval",
    "difficulty": "Medium",
    "codeanswer": "def eraseOverlapIntervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    end = float('-inf')\n    count = 0\n    for interval in intervals:\n        if interval[0] >= end:\n            end = interval[1]\n        else:\n            count += 1\n    return count\n",
    "answerexplanation": "The function sorts the intervals by their end times and iterates through them, keeping track of the end time of the last non-overlapping interval. If an interval overlaps, it increments the count of intervals to remove."
  },
  {
    "id": 30,
    "title": "Meeting Rooms",
    "description": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.",
    "example": "Example: intervals = [[0,30],[5,10],[15,20]] -> false",
    "answer": "Answer for Meeting Rooms",
    "type": "Interval",
    "difficulty": "Easy",
    "codeanswer": "def canAttendMeetings(intervals):\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n    return True\n",
    "answerexplanation": "The function sorts the intervals by their start times and then checks if any interval overlaps with the previous interval. If it does, it returns False."
  },
  {
    "id": 31,
    "title": "Meeting Rooms II",
    "description": "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.",
    "example": "Example: intervals = [[0,30],[5,10],[15,20]] -> 2",
    "answer": "Answer for Meeting Rooms II",
    "type": "Interval",
    "difficulty": "Medium",
    "codeanswer": "def minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n    start_times = sorted(interval.start for interval in intervals)\n    end_times = sorted(interval.end for interval in intervals)\n    start_ptr, end_ptr = 0, 0\n    rooms = 0\n    while start_ptr < len(intervals):\n        if start_times[start_ptr] >= end_times[end_ptr]:\n            rooms -= 1\n            end_ptr += 1\n        rooms += 1\n        start_ptr += 1\n    return rooms\n",
    "answerexplanation": "The function separates the start and end times, sorts them, and then uses two pointers to track the number of rooms needed. It increments the room count when a new meeting starts and decrements it when a meeting ends."
  },
  {
    "id": 32,
    "title": "Minimum Window Substring",
    "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".",
    "example": "Example: s = \"ADOBECODEBANC\", t = \"ABC\" -> \"BANC\"",
    "answer": "Answer for Minimum Window Substring",
    "type": "String",
    "difficulty": "Hard",
    "codeanswer": "def minWindow(s, t):\n    from collections import Counter\n    if not t or not s:\n        return \"\"\n    dict_t = Counter(t)\n    required = len(dict_t)\n    l, r = 0, 0\n    formed = 0\n    window_counts = {}\n    ans = float(\"inf\"), None, None\n    while r < len(s):\n        character = s[r]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        while l <= r and formed == required:\n            character = s[l]\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            l += 1\n        r += 1\n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]: ans[2] + 1]\n",
    "answerexplanation": "The function uses a sliding window approach to find the minimum window substring. It expands the window by moving the right pointer and contracts it by moving the left pointer. It keeps track of the character counts in the window and updates the result when a valid window is found."
  },
  {
    "id": 33,
    "title": "Valid Anagram",
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "example": "Example: s = \"anagram\", t = \"nagaram\" -> true",
    "answer": "Answer for Valid Anagram",
    "type": "String",
    "difficulty": "Easy",
    "codeanswer": "def isAnagram(s, t):\n    return sorted(s) == sorted(t)\n",
    "answerexplanation": "The function checks if the two strings are anagrams by sorting them and comparing the sorted strings."
  },
  {
    "id": 34,
    "title": "Group Anagrams",
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
    "example": "Example: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] -> [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
    "answer": "Answer for Group Anagrams",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def groupAnagrams(strs):\n    from collections import defaultdict\n    ans = defaultdict(list)\n    for s in strs:\n        ans[tuple(sorted(s))].append(s)\n    return list(ans.values())\n",
    "answerexplanation": "The function uses a defaultdict to group anagrams together. It sorts each string and uses the sorted tuple as the key to group the anagrams."
  },
  {
    "id": 35,
    "title": "Valid Parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    "example": "Example: s = \"()[]{}\" -> true",
    "answer": "Answer for Valid Parentheses",
    "type": "String",
    "difficulty": "Easy",
    "codeanswer": "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n",
    "answerexplanation": "The function uses a stack to keep track of the opening parentheses. It checks if the current closing parenthesis matches the top of the stack. If not, it returns False."
  },
  {
    "id": 36,
    "title": "Generate Parentheses",
    "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    "example": "Example: n = 3 -> [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
    "answer": "Answer for Generate Parentheses",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def generateParentheses(n):\n    def backtrack(s='', left=0, right=0):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n    result = []\n    backtrack()\n    return result\n",
    "answerexplanation": "The function uses backtracking to generate all combinations of well-formed parentheses. It keeps track of the number of left and right parentheses used and ensures that the number of right parentheses never exceeds the number of left parentheses."
  },
  {
    "id": 37,
    "title": "Longest Valid Parentheses",
    "description": "Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.",
    "example": "Example: s = \"(()\" -> 2",
    "answer": "Answer for Longest Valid Parentheses",
    "type": "String",
    "difficulty": "Hard",
    "codeanswer": "def longestValidParentheses(s):\n    stack = [-1]\n    max_length = 0\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        else:\n            stack.pop()\n            if not stack:\n                stack.append(i)\n            else:\n                max_length = max(max_length, i - stack[-1])\n    return max_length\n",
    "answerexplanation": "The function uses a stack to keep track of the indices of the parentheses. It calculates the length of the valid substring by subtracting the index of the last unmatched parenthesis from the current index."
  },
  {
    "id": 38,
    "title": "Valid Palindrome",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.",
    "example": "Example: s = \"A man, a plan, a canal: Panama\" -> true",
    "answer": "Answer for Valid Palindrome",
    "type": "String",
    "difficulty": "Easy",
    "codeanswer": "def isPalindrome(s):\n    filtered_chars = filter(lambda x: x.isalnum(), s)\n    lowercase_filtered_chars = map(lambda x: x.lower(), filtered_chars)\n    filtered_string = ''.join(lowercase_filtered_chars)\n    return filtered_string == filtered_string[::-1]\n",
    "answerexplanation": "The function filters out non-alphanumeric characters and converts the remaining characters to lowercase. It then checks if the filtered string is equal to its reverse."
  },
  {
    "id": 39,
    "title": "Minimum Remove to Make Valid Parentheses",
    "description": "Given a string s of '(' , ')' and lowercase English characters, remove the minimum number of parentheses (in any positions) so that the resulting parentheses string is valid and return any valid string.",
    "example": "Example: s = \"lee(t(c)o)de)\" -> \"lee(t(c)o)de\"",
    "answer": "Answer for Minimum Remove to Make Valid Parentheses",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def minRemoveToMakeValid(s):\n    indexes_to_remove = set()\n    stack = []\n    for i, char in enumerate(s):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                indexes_to_remove.add(i)\n    indexes_to_remove = indexes_to_remove.union(set(stack))\n    return ''.join([char for i, char in enumerate(s) if i not in indexes_to_remove])\n",
    "answerexplanation": "The function uses a stack to keep track of the indices of the parentheses. It adds the indices of the unmatched parentheses to a set and removes the characters at those indices from the string."
  },
  {
    "id": 40,
    "title": "Longest Palindromic Substring",
    "description": "Given a string s, return the longest palindromic substring in s.",
    "example": "Example: s = \"babad\" -> \"bab\"",
    "answer": "Answer for Longest Palindromic Substring",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def longestPalindrome(s):\n    def expand_around_center(s, left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    if not s or len(s) == 0:\n        return \"\"\n    start, end = 0, 0\n    for i in range(len(s)):\n        len1 = expand_around_center(s, i, i)\n        len2 = expand_around_center(s, i, i + 1)\n        max_len = max(len1, len2)\n        if max_len > end - start:\n            start = i - (max_len - 1) // 2\n            end = i + max_len // 2\n    return s[start:end + 1]\n",
    "answerexplanation": "The function uses the expand around center technique to find the longest palindromic substring. It checks both odd and even length palindromes by expanding around each character and each pair of characters."
  },
  {
    "id": 41,
    "title": "Palindromic Substrings",
    "description": "Given a string s, return the number of palindromic substrings in it.",
    "example": "Example: s = \"aaa\" -> 6",
    "answer": "Answer for Palindromic Substrings",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def countSubstrings(s):\n    def expand_around_center(s, left, right):\n        count = 0\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n            count += 1\n        return count\n    count = 0\n    for i in range(len(s)):\n        count += expand_around_center(s, i, i)\n        count += expand_around_center(s, i, i + 1)\n    return count\n",
    "answerexplanation": "The function uses the expand around center technique to count the number of palindromic substrings. It expands around each character and each pair of characters, incrementing the count for each valid palindrome found."
  },
  {
    "id": 42,
    "title": "Encode and Decode Strings",
    "description": "Design an algorithm to encode a list of strings to a string, and decode the string to the list of strings.",
    "example": "Example: strings = [\"Hello\",\"World\"] -> \"5#Hello5#World\"",
    "answer": "Answer for Encode and Decode Strings",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def encode(strs):\n    return ''.join(f'{len(s)}#{s}' for s in strs)\n\ndef decode(s):\n    i = 0\n    result = []\n    while i < len(s):\n        j = i\n        while s[j] != '#':\n            j += 1\n        length = int(s[i:j])\n        result.append(s[j+1:j+1+length])\n        i = j + 1 + length\n    return result\n",
    "answerexplanation": "The encode function concatenates each string with its length and a '#' separator. The decode function parses the encoded string by extracting the length and the corresponding substring."
  },
  {
    "id": 43,
    "title": "Maximum Depth of Binary Tree",
    "description": "Given the root of a binary tree, return its maximum depth.",
    "example": "Example: root = [3,9,20,null,null,15,7] -> 3",
    "answer": "Answer for Maximum Depth of Binary Tree",
    "type": "Tree",
    "difficulty": "Easy",
    "codeanswer": "def maxDepth(root):\n    if not root:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n",
    "answerexplanation": "The function uses recursion to find the maximum depth of the binary tree. It returns 1 plus the maximum depth of the left and right subtrees."
  },
  {
    "id": 44,
    "title": "Same Tree",
    "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
    "example": "Example: p = [1,2,3], q = [1,2,3] -> true",
    "answer": "Answer for Same Tree",
    "type": "Tree",
    "difficulty": "Easy",
    "codeanswer": "def isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    return p.val == q.val and isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n",
    "answerexplanation": "The function uses recursion to check if the two trees are the same. It compares the root values and recursively checks the left and right subtrees."
  },
  {
    "id": 45,
    "title": "Invert Binary Tree",
    "description": "Invert a binary tree.",
    "example": "Example: root = [4,2,7,1,3,6,9] -> [4,7,2,9,6,3,1]",
    "answer": "Answer for Invert Binary Tree",
    "type": "Tree",
    "difficulty": "Easy",
    "codeanswer": "def invertTree(root):\n    if not root:\n        return None\n    root.left, root.right = invertTree(root.right), invertTree(root.left)\n    return root\n",
    "answerexplanation": "The function uses recursion to invert the binary tree. It swaps the left and right children of each node."
  },
  {
    "id": 46,
    "title": "Binary Tree Maximum Path Sum",
    "description": "Given a non-empty binary tree, find the maximum path sum.",
    "example": "Example: root = [1,2,3] -> 6",
    "answer": "Answer for Binary Tree Maximum Path Sum",
    "type": "Tree",
    "difficulty": "Hard",
    "codeanswer": "def maxPathSum(root):\n    def helper(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        left = max(helper(node.left), 0)\n        right = max(helper(node.right), 0)\n        max_sum = max(max_sum, node.val + left + right)\n        return node.val + max(left, right)\n    max_sum = float('-inf')\n    helper(root)\n    return max_sum\n",
    "answerexplanation": "The function uses recursion to find the maximum path sum. It calculates the maximum path sum for each node by considering the maximum sums of the left and right subtrees. It updates the global maximum path sum if the current path sum is greater."
  },
  {
    "id": 47,
    "title": "Binary Tree Level Order Traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values.",
    "example": "Example: root = [3,9,20,null,null,15,7] -> [[3],[9,20],[15,7]]",
    "answer": "Answer for Binary Tree Level Order Traversal",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "def levelOrder(root):\n    if not root:\n        return []\n    result, queue = [], [root]\n    while queue:\n        level = []\n        for i in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n    return result\n",
    "answerexplanation": "The function uses a queue to perform level order traversal of the binary tree. It iterates through each level of the tree and adds the node values to the result list."
  },
  {
    "id": 48,
    "title": "Serialize and Deserialize Binary Tree",
    "description": "Design an algorithm to serialize and deserialize a binary tree.",
    "example": "Example: root = [1,2,3,null,null,4,5] -> \"1,2,3,null,null,4,5\"",
    "answer": "Answer for Serialize and Deserialize Binary Tree",
    "type": "Tree",
    "difficulty": "Hard",
    "codeanswer": "def serialize(root):\n    def helper(node):\n        if not node:\n            return 'null'\n        return str(node.val) + ',' + helper(node.left) + ',' + helper(node.right)\n    return helper(root)\n\ndef deserialize(data):\n    def helper(nodes):\n        val = nodes.pop(0)\n        if val == 'null':\n            return None\n        node = TreeNode(int(val))\n        node.left = helper(nodes)\n        node.right = helper(nodes)\n        return node\n    return helper(data.split(','))\n",
    "answerexplanation": "The serialize function converts the binary tree into a string using preorder traversal. The deserialize function reconstructs the binary tree from the serialized string using a helper function."
  },
  {
    "id": 49,
    "title": "Subtree of Another Tree",
    "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.",
    "example": "Example: root = [3,4,5,1,2], subRoot = [4,1,2] -> true",
    "answer": "Answer for Subtree of Another Tree",
    "type": "Tree",
    "difficulty": "Easy",
    "codeanswer": "def isSubtree(root, subRoot):\n    def is_same_tree(p, q):\n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)\n    if not root:\n        return False\n    if is_same_tree(root, subRoot):\n        return True\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n",
    "answerexplanation": "The function uses a helper function to check if two trees are the same. It then checks if the subtree is the same as the root or if it is a subtree of the left or right subtrees."
  },
  {
    "id": 50,
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
    "example": "Example: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] -> [3,9,20,null,null,15,7]",
    "answer": "Answer for Construct Binary Tree from Preorder and Inorder Traversal",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "def buildTree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    root_val = preorder.pop(0)\n    root = TreeNode(root_val)\n    inorder_index = inorder.index(root_val)\n    root.left = buildTree(preorder, inorder[:inorder_index])\n    root.right = buildTree(preorder, inorder[inorder_index + 1:])\n    return root\n",
    "answerexplanation": "The function constructs the binary tree by recursively finding the root from the preorder list and splitting the inorder list into left and right subtrees."
  },
  {
    "id": 51,
    "title": "Validate Binary Search Tree",
    "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
    "example": "Example: root = [2,1,3] -> true",
    "answer": "Answer for Validate Binary Search Tree",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "def isValidBST(root):\n    def helper(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if not (low < node.val < high):\n            return False\n        return helper(node.left, low, node.val) and helper(node.right, node.val, high)\n    return helper(root)\n",
    "answerexplanation": "The function uses recursion to check if the tree is a valid BST. It ensures that each node value is within a valid range defined by the low and high parameters."
  },
  {
    "id": 52,
    "title": "Kth Smallest Element in a BST",
    "description": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
    "example": "Example: root = [3,1,4,null,2], k = 1 -> 1",
    "answer": "Answer for Kth Smallest Element in a BST",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "def kthSmallest(root, k):\n    def inorder(node):\n        return inorder(node.left) + [node.val] + inorder(node.right) if node else []\n    return inorder(root)[k - 1]\n",
    "answerexplanation": "The function uses inorder traversal to get the elements of the BST in sorted order and returns the k-th smallest element."
  },
  {
    "id": 53,
    "title": "Lowest Common Ancestor of a BST",
    "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.",
    "example": "Example: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 -> 6",
    "answer": "Answer for Lowest Common Ancestor of a BST",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "def lowestCommonAncestor(root, p, q):\n    while root:\n        if p.val < root.val and q.val < root.val:\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n",
    "answerexplanation": "The function iteratively finds the lowest common ancestor by traversing the tree and comparing the values of the nodes."
  },
  {
    "id": 54,
    "title": "Implement Trie (Prefix Tree)",
    "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
    "example": "Example: trie = [\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"] -> [null,null,false,true]",
    "answer": "Answer for Implement Trie (Prefix Tree)",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n",
    "answerexplanation": "The Trie class implements the TrieNode class to store the children and end of word flag. It provides insert, search, and startsWith methods to perform the required operations on the trie."
  },
  {
    "id": 55,
    "title": "Add and Search Word",
    "description": "Design a data structure that supports the addition of new words and the search of words.",
    "example": "Example: addWord(\"bad\"), search(\"b.d\") -> true",
    "answer": "Answer for Add and Search Word",
    "type": "Tree",
    "difficulty": "Medium",
    "codeanswer": "class WordDictionary:\n    def __init__(self):\n        self.trie = Trie()\n\n    def addWord(self, word):\n        self.trie.insert(word)\n\n    def search(self, word):\n        def search_in_node(word, node):\n            for i, char in enumerate(word):\n                if char == '.':\n                    return any(search_in_node(word[i+1:], node.children[child]) for child in node.children)\n                else:\n                    if char not in node.children:\n                        return False\n                    node = node.children[char]\n            return node.is_end_of_word\n        return search_in_node(word, self.trie.root)\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n",
    "answerexplanation": "The WordDictionary class uses a trie to store the words. It provides addWord and search methods to add new words and search for words with support for '.' as a wildcard character."
  },
  {
    "id": 56,
    "title": "Word Search II",
    "description": "Given an m x n board of characters and a list of strings words, return all words on the board.",
    "example": "Example: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"] -> [\"oath\",\"eat\"]",
    "answer": "Answer for Word Search II",
    "type": "Tree",
    "difficulty": "Hard",
    "codeanswer": "def findWords(board, words):\n    def backtrack(i, j, node, prefix):\n        if node.is_end_of_word:\n            result.add(prefix)\n        if not (0 <= i < m and 0 <= j < n) or board[i][j] not in node.children:\n            return\n        char = board[i][j]\n        board[i][j] = '#'  # mark as visited\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            backtrack(i + x, j + y, node.children[char], prefix + char)\n        board[i][j] = char  # unmark\n\n    result = set()\n    trie = Trie()\n    for word in words:\n        trie.insert(word)\n    m, n = len(board), len(board[0])\n    for i in range(m):\n        for j in range(n):\n            backtrack(i, j, trie.root, '')\n    return list(result)\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n",
    "answerexplanation": "The function uses a trie to store the words and backtracking to search for the words on the board. It marks the cells as visited during the search and adds the found words to the result set."
  },
  {
    "id": 57,
    "title": "Merge K Sorted Lists",
    "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.",
    "example": "Example: lists = [[1,4,5],[1,3,4],[2,6]] -> [1,1,2,3,4,4,5,6]",
    "answer": "Answer for Merge K Sorted Lists",
    "type": "Heap",
    "difficulty": "Hard",
    "codeanswer": "def mergeKLists(lists):\n    import heapq\n    heap = []\n    for l in lists:\n        while l:\n            heapq.heappush(heap, l.val)\n            l = l.next\n    dummy = ListNode(0)\n    curr = dummy\n    while heap:\n        curr.next = ListNode(heapq.heappop(heap))\n        curr = curr.next\n    return dummy.next\n",
    "answerexplanation": "The function uses a min-heap to merge the k sorted lists. It adds all the elements of the lists to the heap and then constructs a new sorted list by popping the elements from the heap."
  },
  {
    "id": 58,
    "title": "Top K Frequent Elements",
    "description": "Given an integer array nums and an integer k, return the k most frequent elements.",
    "example": "Example: nums = [1,1,1,2,2,3], k = 2 -> [1,2]",
    "answer": "Answer for Top K Frequent Elements",
    "type": "Heap",
    "difficulty": "Medium",
    "codeanswer": "def topKFrequent(nums, k):\n    from collections import Counter\n    import heapq\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)\n",
    "answerexplanation": "The function uses a Counter to count the frequency of each element and a min-heap to find the k most frequent elements."
  },
  {
    "id": 59,
    "title": "Find Median from Data Stream",
    "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.",
    "example": "Example: MedianFinder, addNum(1), addNum(2), findMedian() -> 1.5",
    "answer": "Answer for Find Median from Data Stream",
    "type": "Heap",
    "difficulty": "Hard",
    "codeanswer": "class MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap\n        self.large = []  # min-heap\n\n    def addNum(self, num):\n        if len(self.small) == len(self.large):\n            heapq.heappush(self.large, -heapq.heappushpop(self.small, -num))\n        else:\n            heapq.heappush(self.small, -heapq.heappushpop(self.large, num))\n\n    def findMedian(self):\n        if len(self.small) == len(self.large):\n            return (-self.small[0] + self.large[0]) / 2\n        else:\n            return self.large[0]\n",
    "answerexplanation": "The class uses two heaps to store the numbers. The max-heap stores the smaller half of the numbers and the min-heap stores the larger half. The addNum method ensures that the heaps are balanced, and the findMedian method returns the median based on the sizes of the heaps."
  },
  {
    "id": 60,
    "title": "Reverse a Linked List",
    "description": "Reverse a singly linked list.",
    "example": "Example: head = [1,2,3,4,5] -> [5,4,3,2,1]",
    "answer": "Answer for Reverse a Linked List",
    "type": "Linked List",
    "difficulty": "Easy",
    "codeanswer": "def reverseList(head):\n    prev = None\n    curr = head\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    return prev\n",
    "answerexplanation": "The function uses iteration to reverse the linked list. It iterates through the list and reverses the pointers of each node."
  },
  {
    "id": 61,
    "title": "Detect Cycle in a Linked List",
    "description": "Given a linked list, return the node where the cycle begins. If there is no cycle, return null.",
    "example": "Example: head = [3,2,0,-4], pos = 1 -> 2",
    "answer": "Answer for Detect Cycle in a Linked List",
    "type": "Linked List",
    "difficulty": "Medium",
    "codeanswer": "def detectCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n    return None\n",
    "answerexplanation": "The function uses the Floyd's Tortoise and Hare algorithm to detect the cycle. It uses two pointers, slow and fast, to find the meeting point inside the cycle. Then, it resets one pointer to the head and moves both pointers at the same speed until they meet at the cycle start."
  },
  {
    "id": 62,
    "title": "Merge Two Sorted Lists",
    "description": "Merge two sorted linked lists and return it as a new sorted list.",
    "example": "Example: l1 = [1,2,4], l2 = [1,3,4] -> [1,1,2,3,4,4]",
    "answer": "Answer for Merge Two Sorted Lists",
    "type": "Linked List",
    "difficulty": "Easy",
    "codeanswer": "def mergeTwoLists(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n    while l1 and l2:\n        if l1.val < l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 or l2\n    return dummy.next\n",
    "answerexplanation": "The function uses iteration to merge the two sorted lists. It iterates through both lists and adds the smaller node to the new list. It continues until one of the lists is exhausted and then adds the remaining nodes from the other list."
  },
  {
    "id": 63,
    "title": "Merge K Sorted Lists",
    "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.",
    "example": "Example: lists = [[1,4,5],[1,3,4],[2,6]] -> [1,1,2,3,4,4,5,6]",
    "answer": "Answer for Merge K Sorted Lists",
    "type": "Linked List",
    "difficulty": "Hard",
    "codeanswer": "def mergeKLists(lists):\n    import heapq\n    heap = []\n    for l in lists:\n        while l:\n            heapq.heappush(heap, l.val)\n            l = l.next\n    dummy = ListNode(0)\n    curr = dummy\n    while heap:\n        curr.next = ListNode(heapq.heappop(heap))\n        curr = curr.next\n    return dummy.next\n",
    "answerexplanation": "The function uses a min-heap to merge the k sorted lists. It adds all the elements of the lists to the heap and then constructs a new sorted list by popping the elements from the heap."
  },
  {
    "id": 64,
    "title": "Remove Nth Node From End of List",
    "description": "Given a linked list, remove the n-th node from the end of list and return its head.",
    "example": "Example: head = [1,2,3,4,5], n = 2 -> [1,2,3,5]",
    "answer": "Answer for Remove Nth Node From End of List",
    "type": "Linked List",
    "difficulty": "Medium",
    "codeanswer": "def removeNthFromEnd(head, n):\n    dummy = ListNode(0)\n    dummy.next = head\n    first = second = dummy\n    for _ in range(n + 1):\n        first = first.next\n    while first:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next\n",
    "answerexplanation": "The function uses two pointers, first and second, to remove the n-th node from the end. It moves the first pointer n+1 steps ahead and then moves both pointers until the first pointer reaches the end. The second pointer is then at the node before the node to be removed."
  },
  {
    "id": 65,
    "title": "Reorder List",
    "description": "Given a singly linked list L: L0L1Ln-1Ln, reorder it to: L0LnL1Ln-1L2Ln-2",
    "example": "Example: head = [1,2,3,4] -> [1,4,2,3]",
    "answer": "Answer for Reorder List",
    "type": "Linked List",
    "difficulty": "Medium",
    "codeanswer": "def reorderList(head):\n    if not head:\n        return\n    # Find the middle of the list\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    # Reverse the second half\n    prev, curr = None, slow\n    while curr:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    # Merge the two halves\n    first, second = head, prev\n    while second.next:\n        first.next, first = second, first.next\n        second.next, second = first, second.next\n",
    "answerexplanation": "The function finds the middle of the list, reverses the second half, and then merges the two halves to reorder the list."
  },
  {
    "id": 66,
    "title": "Set Matrix Zeroes",
    "description": "Given an m x n matrix. If an element is 0, set its entire row and column to 0. Do it in-place.",
    "example": "Example: matrix = [[1,1,1],[1,0,1],[1,1,1]] -> [[1,0,1],[0,0,0],[1,0,1]]",
    "answer": "Answer for Set Matrix Zeroes",
    "type": "Matrix",
    "difficulty": "Medium",
    "codeanswer": "def setZeroes(matrix):\n    is_col = False\n    R, C = len(matrix), len(matrix[0])\n    for i in range(R):\n        if matrix[i][0] == 0:\n            is_col = True\n        for j in range(1, C):\n            if matrix[i][j] == 0:\n                matrix[0][j] = 0\n                matrix[i][0] = 0\n    for i in range(1, R):\n        for j in range(1, C):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    if matrix[0][0] == 0:\n        for j in range(C):\n            matrix[0][j] = 0\n    if is_col:\n        for i in range(R):\n            matrix[i][0] = 0\n",
    "answerexplanation": "The function uses the first row and first column to mark the rows and columns that need to be set to zero. It then sets the elements to zero based on the markers and finally handles the first row and first column separately."
  },
  {
    "id": 67,
    "title": "Spiral Matrix",
    "description": "Given an m x n matrix, return all elements of the matrix in spiral order.",
    "example": "Example: matrix = [[1,2,3],[4,5,6],[7,8,9]] -> [1,2,3,6,9,8,7,4,5]",
    "answer": "Answer for Spiral Matrix",
    "type": "Matrix",
    "difficulty": "Medium",
    "codeanswer": "def spiralOrder(matrix):\n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    return result\n",
    "answerexplanation": "The function iteratively removes the first row, the last column, the last row, and the first column from the matrix and adds the elements to the result list in spiral order."
  },
  {
    "id": 68,
    "title": "Rotate Image",
    "description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).",
    "example": "Example: matrix = [[1,2,3],[4,5,6],[7,8,9]] -> [[7,4,1],[8,5,2],[9,6,3]]",
    "answer": "Answer for Rotate Image",
    "type": "Matrix",
    "difficulty": "Medium",
    "codeanswer": "def rotate(matrix):\n    matrix[:] = zip(*matrix[::-1])\n",
    "answerexplanation": "The function uses the zip function to transpose the matrix and then reverses each row to rotate the image by 90 degrees clockwise."
  },
  {
    "id": 69,
    "title": "Word Search",
    "description": "Given an m x n board of characters and a word, find if the word exists in the grid.",
    "example": "Example: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" -> true",
    "answer": "Answer for Word Search",
    "type": "Matrix",
    "difficulty": "Medium",
    "codeanswer": "def exist(board, word):\n    def backtrack(i, j, k):\n        if not (0 <= i < len(board) and 0 <= j < len(board[0])):\n            return False\n        if board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n        temp, board[i][j] = board[i][j], '#'\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if backtrack(i + x, j + y, k + 1):\n                return True\n        board[i][j] = temp\n        return False\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if backtrack(i, j, 0):\n                return True\n    return False\n",
    "answerexplanation": "The function uses backtracking to search for the word in the board. It marks the cells as visited during the search and restores them after the search."
  },
  {
    "id": 70,
    "title": "Longest Substring Without Repeating Characters",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "example": "Example: s = \"abcabcbb\" -> 3",
    "answer": "Answer for Longest Substring Without Repeating Characters",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def lengthOfLongestSubstring(s):\n    char_map = {}\n    left = 0\n    max_length = 0\n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        char_map[s[right]] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length\n",
    "answerexplanation": "The function uses a sliding window approach with a hashmap to store the last seen index of each character. It moves the left pointer to the right when a duplicate character is found and updates the maximum length of the substring."
  },
  {
    "id": 71,
    "title": "Longest Repeating Character Replacement",
    "description": "Given a string s that consists of only uppercase English letters, you can perform at most k operations on that string. In one operation, you can choose any character of the string and change it to any other uppercase English character.",
    "example": "Example: s = \"AABABBA\", k = 1 -> 4",
    "answer": "Answer for Longest Repeating Character Replacement",
    "type": "String",
    "difficulty": "Medium",
    "codeanswer": "def characterReplacement(s, k):\n    count = {}\n    max_count = 0\n    left = 0\n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        if right - left + 1 - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n    return len(s) - left\n",
    "answerexplanation": "The function uses a sliding window approach with a hashmap to store the count of each character. It maintains the maximum count of any character in the window and adjusts the window size based on the allowed number of operations."
  },
  {
    "id": 72,
    "title": "Clone Graph",
    "description": "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph.",
    "example": "Example: adjList = [[2,4],[1,3],[2,4],[1,3]] -> [[2,4],[1,3],[2,4],[1,3]]",
    "answer": "Answer for Clone Graph",
    "type": "Graph",
    "difficulty": "Medium",
    "codeanswer": "def cloneGraph(node):\n    if not node:\n        return None\n    visited = {}\n    def clone(node):\n        if node in visited:\n            return visited[node]\n        copy = Node(node.val, [])\n        visited[node] = copy\n        for neighbor in node.neighbors:\n            copy.neighbors.append(clone(neighbor))\n        return copy\n    return clone(node)\n",
    "answerexplanation": "The function uses recursion and a hashmap to clone the graph. It creates a copy of each node and its neighbors and stores the copies in the hashmap to avoid duplicate nodes."
  },
  {
    "id": 73,
    "title": "Course Schedule",
    "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]. Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?",
    "example": "Example: numCourses = 2, prerequisites = [[1,0]] -> true",
    "answer": "Answer for Course Schedule",
    "type": "Graph",
    "difficulty": "Medium",
    "codeanswer": "def canFinish(numCourses, prerequisites):\n    from collections import defaultdict, deque\n    graph = defaultdict(list)\n    indegree = [0] * numCourses\n    for dest, src in prerequisites:\n        graph[src].append(dest)\n        indegree[dest] += 1\n    queue = deque([i for i in range(numCourses) if indegree[i] == 0])\n    count = 0\n    while queue:\n        node = queue.popleft()\n        count += 1\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n    return count == numCourses\n",
    "answerexplanation": "The function uses topological sorting with a queue to check if all courses can be finished. It builds the graph and indegree array, then processes nodes with zero indegree and updates the indegree of their neighbors."
  },
  {
    "id": 74,
    "title": "Pacific Atlantic Water Flow",
    "description": "Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.",
    "example": "Example: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]] -> [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
    "answer": "Answer for Pacific Atlantic Water Flow",
    "type": "Graph",
    "difficulty": "Medium",
    "codeanswer": "def pacificAtlantic(heights):\n    if not heights or not heights[0]:\n        return []\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n    def dfs(i, j, ocean):\n        ocean[i][j] = True\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            ni, nj = i + x, j + y\n            if 0 <= ni < m and 0 <= nj < n and not ocean[ni][nj] and heights[ni][nj] >= heights[i][j]:\n                dfs(ni, nj, ocean)\n    for i in range(m):\n        dfs(i, 0, pacific)\n        dfs(i, n - 1, atlantic)\n    for j in range(n):\n        dfs(0, j, pacific)\n        dfs(m - 1, j, atlantic)\n    return [[i, j] for i in range(m) for j in range(n) if pacific[i][j] and atlantic[i][j]]\n",
    "answerexplanation": "The function uses DFS to mark the cells that can reach the Pacific and Atlantic oceans. It starts from the cells adjacent to the oceans and marks the reachable cells. Finally, it returns the cells that can reach both oceans."
  },
  {
    "id": 75,
    "title": "Number of Islands",
    "description": "Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
    "example": "Example: grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]] -> 3",
    "answer": "Answer for Number of Islands",
    "type": "Graph",
    "difficulty": "Medium",
    "codeanswer": "def numIslands(grid):\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    def dfs(i, j):\n        if not (0 <= i < m and 0 <= j < n) or grid[i][j] == '0':\n            return\n        grid[i][j] = '0'\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            dfs(i + x, j + y)\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                dfs(i, j)\n                count += 1\n    return count\n",
    "answerexplanation": "The function uses DFS to count the number of islands. It iterates through the grid and performs DFS to mark all the connected land cells as water. It increments the count for each island found."
  }
]
